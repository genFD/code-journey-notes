# TypeScript Fundamentals v3

Leverage TypeScript's strengths to provide clarity in the face of complexity, while protecting your codebase and team from it's weaknesses.

## 1 Intro

We'll discuss the goals and agenda of this course, and how to get up and running with the workshop project in 2 minutes or less.

## 2 Hello TypeScript

In this chapter, we'll get hands on with our first TypeScript program and the compiler CLI command, and examine a simple program's compiled output

## 3 Variables and Values

We will begin our study of the TypeScript language with simple variables and functions.

## 4 Objects, Arrays and Tuples

Now that we know how to type simple variables and functions, let's make things a bit more interesting with collections: in JavaScript this includes Objects and Arrays.

## 5 Structural vs. Nominal Types

In this unit, we will explore how TypeScript is fundamentally different from nominal type systems, such as the ones found in Java and C++.

## 6 Union and Intersection Types

We will discuss and explore TypeScript's union and intersection types, which are effectively "AND" and "OR" boolean logic operators for types.

## 7 Interfaces and Type Aliases

TypeScript provides two mechanisms for centrally defining types and giving them useful and meaningful names: interfaces and type aliases. We will study both concepts in depth, and explain when it makes sense to use each.

## 8 JSON types

We will take on our first challenge together: defining types that describe any valid JSON value

## 9 Functions

So far, we have dealt with function argument and return types. There are a few more in-depth features we need to cover, including multiple function heads and callable types.

## 10 Classes

TypeScript classes add some powerful and important features on top of traditional JavaScript classes. In this unit, we will take a close look class fields, access modifier keywords and more!

## 11 Top and bottom types

Top types can be anything, bottom types can't be anything. We will also look at three "extreme types" in TypeScript: any, unknown and never.

## 12 Type guards and narrowing

We have explored built-in type guards like typeof and instanceof, but there's a lot more power in type guards, including the ability to define your own!

## 13 Nullish values

There are situations where we have to plan for, and deal with the possibility that values are null or undefined. In this chapter, we will dive deep into null, undefined, definite assignment, and the non-null assertion operator.

## 14 Generics

Generics allow us to parameterize types, which unlocks great opportunity to reuse types broadly across a TypeScript project.

## 15 Dictionary map, filter and reduce

Many of us use array the higher-order functions map, filter and reduce quite often. Let's build out similar utilities that operate on dictionaries!

## 16 Generics Scopes and Constraints

In this chapter, we'll learn about scopes and constraints, as they pertain to type params, and what the language would look like if we didn't have these important tools
